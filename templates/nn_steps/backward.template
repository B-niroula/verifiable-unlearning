import "utils/casts/u64_to_bits" as u64_to_bits

const u64 PRECISION = {{precision}}
const u32 NO_FEATURES = {{no_features}}
const u32 NO_NEURONS = {{no_neurons}}

{% for j in range(no_neurons) %}
const u64[NO_FEATURES] W0_{{j}} = {{w0[j]}}
{% endfor %}
const u64[NO_NEURONS] B0 = {{b0}}
const u64[NO_NEURONS] W1 = {{w1}}
const u64 B1 = {{b1}}

const u64 W0 = {{W0}}
const u64 W1S = {{W1S}}
const u64 W3 = {{W3}}

def remove_shift(u64 input) -> u64:
    return if u64_to_bits(input)[0] == true then -1*((-1*input)/PRECISION) else input / PRECISION fi

def sigmoid(u64 x) -> u64:
    return W0 + remove_shift(W1S*x) - remove_shift(W3*remove_shift(remove_shift(x*x)*x))

def main(private u64[NO_FEATURES] x, private u64 y) -> u64:
    u64[NO_NEURONS] a0 = [0; NO_NEURONS]
    u64 z1 = B1
    {% for j in range(no_neurons) %}
    u64 z0_{{j}} = B0[{{j}}]
    for u32 i in 0..NO_FEATURES do
        z0_{{j}} = z0_{{j}} + remove_shift(x[i]*W0_{{j}}[i])
    endfor
    a0[{{j}}] = sigmoid(z0_{{j}})
    z1 = z1 + remove_shift(a0[{{j}}]*W1[{{j}}])
    {% endfor %}
    u64 a1 = sigmoid(z1)
    // backward
    u64 dz1 = a1 - y
    {% for i in range(no_neurons) %}
    u64 dw1_{{i}} = remove_shift(dz1*a0[{{i}}])
    {% endfor %}
    u64 db1 = dz1
    {% for j in range(no_neurons) %}
    u64 da0_{{j}} = remove_shift(dz1*W1[{{j}}])
    u64 dz0_{{j}} = remove_shift(da0_{{j}}*remove_shift(a0[{{j}}]*(1 - a0[{{j}}])))
    for u32 i in 0..NO_FEATURES do
        u64 dw0_{{j}}_{{i}} = remove_shift(dz0_{{j}}*x[i])
    endfor
    u64 db0_{{j}} = dz0_{{j}}
    {% endfor %}
    return dz1
