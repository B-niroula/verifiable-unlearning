import "utils/casts/u64_to_bits" as u64_to_bits

const u64 PRECISION = {{precision}}
const u32 NO_FEATURES = {{no_features}}
const u32 NO_NEURONS = {{no_neurons}}

{% for j in range(no_neurons) %}
const u64[NO_FEATURES] W0_{{j}} = {{w0[j]}}
{% endfor %}
const u64[NO_NEURONS] B0 = {{b0}}
const u64[NO_NEURONS] W1 = {{w1}}
const u64 B1 = {{b1}}

const u64 W0 = {{W0}}
const u64 W1S = {{W1S}}
const u64 W3 = {{W3}}

def remove_shift(u64 input) -> u64:
    return if u64_to_bits(input)[0] == true then -1*((-1*input)/PRECISION) else input / PRECISION fi

def sigmoid(u64 x) -> u64:
    return W0 + remove_shift(W1S*x) - remove_shift(W3*remove_shift(remove_shift(x*x)*x))

def main(private u64[NO_FEATURES] x) -> u64:
    u64[NO_NEURONS] a0 = [0; NO_NEURONS]
    u64 z1 = B1
    {% for j in range(no_neurons) %}
    u64 z0_{{j}} = B0[{{j}}]
    for u32 i in 0..NO_FEATURES do
        z0_{{j}} = z0_{{j}} + remove_shift(x[i]*W0_{{j}}[i])
    endfor
    a0[{{j}}] = sigmoid(z0_{{j}})
    z1 = z1 + remove_shift(a0[{{j}}]*W1[{{j}}])
    {% endfor %}
    u64 a1 = sigmoid(z1)
    return a1
